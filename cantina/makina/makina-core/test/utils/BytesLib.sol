// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.28;

/*
 * @title Solidity Bytes Arrays Utils
 * @author Gonçalo Sá <goncalo.sa@consensys.net>
 *
 * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.
 *      The library lets you type cast bytes arrays.
 *      This version has been truncated and slightly refactored to fit the current project.
 */
library BytesLib {
    error ToUint8OutOfBounds();
    error ToUint16OutOfBounds();
    error ToUint32OutOfBounds();
    error ToUint64OutOfBounds();
    error ToUint96OutOfBounds();
    error ToUint128OutOfBounds();
    error ToUint256OutOfBounds();
    error ToBytes32OutOfBounds();

    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {
        if (_bytes.length < _start + 1) {
            revert ToUint8OutOfBounds();
        }
        uint8 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x1), _start))
        }

        return tempUint;
    }

    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {
        if (_bytes.length < _start + 2) {
            revert ToUint16OutOfBounds();
        }
        uint16 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x2), _start))
        }

        return tempUint;
    }

    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {
        if (_bytes.length < _start + 4) {
            revert ToUint32OutOfBounds();
        }
        uint32 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x4), _start))
        }

        return tempUint;
    }

    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {
        if (_bytes.length < _start + 8) {
            revert ToUint64OutOfBounds();
        }
        uint64 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x8), _start))
        }

        return tempUint;
    }

    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {
        if (_bytes.length < _start + 12) {
            revert ToUint96OutOfBounds();
        }
        uint96 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0xc), _start))
        }

        return tempUint;
    }

    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {
        if (_bytes.length < _start + 16) {
            revert ToUint128OutOfBounds();
        }
        uint128 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x10), _start))
        }

        return tempUint;
    }

    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {
        if (_bytes.length < _start + 32) {
            revert ToUint256OutOfBounds();
        }
        uint256 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x20), _start))
        }

        return tempUint;
    }

    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {
        if (_bytes.length < _start + 32) {
            revert ToBytes32OutOfBounds();
        }
        bytes32 tempBytes32;

        assembly {
            tempBytes32 := mload(add(add(_bytes, 0x20), _start))
        }

        return tempBytes32;
    }
}
